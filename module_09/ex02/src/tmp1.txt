#include <iostream>
#include <vector>
#include <algorithm>

// Function to generate Jacobsthal sequence up to a given size
std::vector<size_t> generateJacobsthal(size_t n) {
    std::vector<size_t> jacobsthal = {0, 1};
    while (jacobsthal.back() < n) {
        jacobsthal.push_back(jacobsthal[jacobsthal.size() - 1] + 2 * jacobsthal[jacobsthal.size() - 2]);
    }
    return jacobsthal;
}

// Ford-Johnson (Merge-Insertion) Sort
std::vector<int> fordJohnsonSort(std::vector<int> input) {
    std::cout << "Debugging Ford-Johnson sort:\nInput: ";
    for (int num : input) std::cout << num << " ";
    std::cout << "\n";

    if (input.size() <= 1) return input;

    // Step 1: Pair elements and sort pairs
    std::vector<int> small, large;
    int extra = -1;

    std::cout << "Forming pairs:\n";
    for (size_t i = 0; i + 1 < input.size(); i += 2) {
        int a = input[i], b = input[i + 1];
        if (a > b) std::swap(a, b);
        small.push_back(a);
        large.push_back(b);
        std::cout << "Pair: " << a << "," << b << " -> " << a << "," << b << "\n";
    }

    if (input.size() % 2 == 1) {
        extra = input.back();
        std::cout << "Extra element: " << extra << "\n";
    }

    // Step 2: Recursively sort the smaller elements
    std::cout << "Small elements before recursive sort: ";
    for (int num : small) std::cout << num << " ";
    std::cout << "\n";

    small = fordJohnsonSort(small);

    std::cout << "Small elements after recursive sort: ";
    for (int num : small) std::cout << num << " ";
    std::cout << "\n";

    // Step 3: Generate Jacobsthal sequence for optimal insertion order
    std::vector<size_t> jacobsthal = generateJacobsthal(large.size());
    std::cout << "Jacobsthal sequence: ";
    for (size_t num : jacobsthal) std::cout << num << " ";
    std::cout << "\n";

    // Step 4: Insert the larger elements into the sorted small elements
    std::vector<int> result = small;
    if (!large.empty()) {
        // Fixing the insertion of large elements
        for (size_t i = 0; i < large.size(); ++i) {
            size_t hint = std::min<size_t>(jacobsthal[i], result.size());
            auto it = std::upper_bound(result.begin(), result.end(), large[i]);
            size_t actualPos = it - result.begin();
            std::cout << "Inserting " << large[i] << " with hint " << hint << "\n";
            std::cout << "Attempting to insert " << large[i] << " at index " << hint << " (actual pos: " << actualPos << ")\n";
            result.insert(result.begin() + actualPos, large[i]);
        }
    }

    // Step 5: Insert the extra element if it exists
    if (extra != -1) {
        auto it = std::upper_bound(result.begin(), result.end(), extra);
        size_t pos = it - result.begin();
        std::cout << "Inserting extra element " << extra << " at position " << pos << "\n";
        result.insert(result.begin() + pos, extra);
    }

    // Step 6: Return the sorted result
    std::cout << "Final result: ";
    for (int num : result) std::cout << num << " ";
    std::cout << "\n";

    return result;
}

int main() {
    std::vector<int> data = {3, 5, 1525, 9, 7, 4, 99, 8, 6, 5};

    std::cout << "Before: ";
    for (int num : data) std::cout << num << " ";
    std::cout << "\n";

    std::vector<int> sortedData = fordJohnsonSort(data);

    std::cout << "After : ";
    for (int num : sortedData) std::cout << num << " ";
    std::cout << "\n";

    return 0;
}

